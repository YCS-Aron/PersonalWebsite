<div class="blog-body">
							<header class="header">
								<div class="title">
									<h1>Javascript相关的兼容问题</h1>
									<p class="subline">DOM,BOM,事件等的兼容性</p>
									<p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/5/27</strong></p>
								</div>
							</header>
							<article class="article-content">
								<div>
									<p>CSS</p>
									<h3>事件处理</h3>
									<p>IE采用全局变量window.event存储事件。</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#3f7f59; '>//IE</span>
$(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>.myclass</span><span style='color:#2a00ff; '>'</span>).addeventlistener(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>click</span><span style='color:#2a00ff; '>'</span> ,<span style='color:#7f0055; font-weight:bold; '>function</span>() {
	<span style='color:#7f0055; font-weight:bold; '>var</span> event = window.event;
	<span style='color:#7f0055; font-weight:bold; '>var</span> element = e.srcElement;
	<span style='color:#7f0055; font-weight:bold; '>var</span> keyCode = e.which;
})
</pre>
									</div>
									<p>firefox采用全局变量函数参数传递事件。</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#3f7f59; '>//firefox</span>
$(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>.myclass</span><span style='color:#2a00ff; '>'</span>).addeventlistener(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>click</span><span style='color:#2a00ff; '>'</span> ,<span style='color:#7f0055; font-weight:bold; '>function</span>(e) {
	<span style='color:#7f0055; font-weight:bold; '>var</span> event = e;
	<span style='color:#7f0055; font-weight:bold; '>var</span> element = e.target;
	<span style='color:#7f0055; font-weight:bold; '>var</span> keyCode = e.keyCode;
})
</pre>
									</div>
									<p>Chrome则支持这两种方法。下面给一个兼容IE,firefox,Chrome的例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#3f7f59; '>//兼容IE,firefox,Chrome</span>
$(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>.myclass</span><span style='color:#2a00ff; '>'</span>).addeventlistener(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>click</span><span style='color:#2a00ff; '>'</span> ,<span style='color:#7f0055; font-weight:bold; '>function</span>() {
	<span style='color:#7f0055; font-weight:bold; '>var</span> event = arguments[0] || window.event;
	<span style='color:#7f0055; font-weight:bold; '>var</span> element = event.target || event.srcElement;
	<span style='color:#7f0055; font-weight:bold; '>var</span> keyCode = event.keyCode || event.which;
})
</pre>
									</div>
								</div>
							</article>
						</div>
					</div>
					<div class="pt-page" index="24">
						<div class="blog-body">
							<header class="header">
								<div class="title">
									<h1>Backbone框架介绍</h1>
									<p class="subline">Backbone组件，优势</p>
									<p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/6/5</strong></p>
								</div>
							</header>
							<article class="article-content">
								<div>
									
								</div>
							</article>
						</div>
					</div>
					<div class="pt-page" index="25">
						<div class="blog-body">
							<header class="header">
								<div class="title">
									<h1>Backbone的Model</h1>
									<p class="subline">Backbone组件之一Model</p>
									<p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/6/5</strong></p>
								</div>
							</header>
							<article class="article-content">
								<div>
									<p>首先，给出官方关于Model的介绍：<a class="link" href="http://backbonejs.org/#Model">Backbone: Model</a>。Model是Backbone用于管理数据的模块，Model的几个重要方面包括：set方法；fetch方法；save方法；如何实现属性的change事件；Model如何实现持久化。</p>
									<p>官方文档中给出了Model的一些可以重载的属性，这些属性描述了Model的具体功能，我们将对这些属性的作用以及源码进行分析。</p>
									<h4>extend</h4>
									<p>该方法是Backbone自定义的方法，不是Underscore提供的_.extend方法。源代码如下：</p>
									<div class="code-block">
<pre><span style='color:#3f7f59; '>// Backbone: line 1556</span>
<span style='color:#3f7f59; '>// protoProps:  JSON</span>
<span style='color:#3f7f59; '>// staticProps: JSON</span>
<span style='color:#3f7f59; '>// 返回一个新的对象child，参数protoProps中的属性会被添加到新对象的prototype中，staticProps中的属性则直接绑定到新对象上作为静态属性</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> extend = <span style='color:#7f0055; font-weight:bold; '>function</span>(protoProps, staticProps) {
    <span style='color:#7f0055; font-weight:bold; '>var</span> parent = <span style='color:#7f0055; font-weight:bold; '>this</span>;
    <span style='color:#7f0055; font-weight:bold; '>var</span> child;

    <span style='color:#3f7f59; '>//管理子类的constructor属性</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span> (protoProps &amp;&amp; _.has(protoProps, <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>constructor</span><span style='color:#2a00ff; '>'</span>)) {
      child = protoProps.constructor;
    } <span style='color:#7f0055; font-weight:bold; '>else</span> {
      child = <span style='color:#7f0055; font-weight:bold; '>function</span>(){ <span style='color:#7f0055; font-weight:bold; '>return</span> parent.apply(<span style='color:#7f0055; font-weight:bold; '>this</span>, arguments); };
    }

    <span style='color:#3f7f59; '>//将parent和staticProps上的属性复制到child对象上</span>
    <span style='color:#3f7f59; '>//parent是子类的静态成员对象，即this，比如Backbone.Model.extend()，parent就是Model上的静态属性</span>
    <span style='color:#3f7f59; '>//staticProps中的属性是子类要新添加的静态属性</span>
    <span style='color:#3f7f59; '>//这样会操作到parent中的prototype属性，但是后面会被覆盖重写</span>
    _.extend(child, parent, staticProps);

    <span style='color:#3f7f59; '>//构造prototype对象，其中包含有子类prototype所有的属性和constructor属性，并赋值给child.prototype</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> Surrogate = <span style='color:#7f0055; font-weight:bold; '>function</span>(){ <span style='color:#7f0055; font-weight:bold; '>this</span>.constructor = child; };
    Surrogate.prototype = parent.prototype;   
    child.prototype = <span style='color:#7f0055; font-weight:bold; '>new</span> Surrogate;          <span style='color:#3f7f59; '>//COOL!!</span>

    <span style='color:#3f7f59; '>//从protoProps中复制属性到子类的prototype中</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span> (protoProps) _.extend(child.prototype, protoProps);

    <span style='color:#3f7f59; '>//将基类的constructor作为子类的静态属性</span>
    child.__super__ = parent.prototype;

    <span style='color:#7f0055; font-weight:bold; '>return</span> child;
};

<span style='color:#3f7f59; '>// Set up inheritance for the model, collection, router, view and history.</span>
Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
</pre>
									</div>
									<p>extend方法使用了Underscore提供的extend方法，用来给对象添加属性。Backbone的extend方法通过扩展prototype属性实现了类似于‘类方法’，使得每个通过new关键字创建的对象都共享同一个函数对象；通过扩展对象本身实现了静态方法，可直接通过函数对象名访问。</p>
									<p>Model,Collection,Router,View,History都会使用extend作为继承的方法。这是框架中非常重要的一个方法，是代码模块化，可扩展的基础。</p>
									<h4>constructor/initialize</h4>
									<p>constructor是Javascript对象提供的方法，不是Backbone定义的方法。</p>
									<div class="code-block">
<pre><span style='color:#3f7f59; '>//Line 248</span>
<span style='color:#3f7f59; '>//Model的constructor</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> Model = Backbone.Model = <span style='color:#7f0055; font-weight:bold; '>function</span>(attributes, options) {
    <span style='color:#7f0055; font-weight:bold; '>var</span> attrs = attributes || {};
    options || (options = {});
    <span style='color:#7f0055; font-weight:bold; '>this</span>.cid = _.uniqueId(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>c</span><span style='color:#2a00ff; '>'</span>);
    <span style='color:#7f0055; font-weight:bold; '>this</span>.attributes = {};
    <span style='color:#7f0055; font-weight:bold; '>if</span> (options.collection) <span style='color:#7f0055; font-weight:bold; '>this</span>.collection = options.collection;
    <span style='color:#7f0055; font-weight:bold; '>if</span> (options.<span style='color:#7f0055; font-weight:bold; '>parse</span>) attrs = <span style='color:#7f0055; font-weight:bold; '>this</span>.<span style='color:#7f0055; font-weight:bold; '>parse</span>(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(<span style='color:#7f0055; font-weight:bold; '>this</span>, <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>defaults</span><span style='color:#2a00ff; '>'</span>));
    <span style='color:#7f0055; font-weight:bold; '>this</span>.set(attrs, options);
    <span style='color:#7f0055; font-weight:bold; '>this</span>.changed = {};
    <span style='color:#7f0055; font-weight:bold; '>this</span>.initialize.apply(<span style='color:#7f0055; font-weight:bold; '>this</span>, arguments);
};
</pre>
<pre>_.extend(Model.prototype, Events, {
    <span style='color:#3f7f59; '>//...</span>

    <span style='color:#3f7f59; '>// Initialize is an empty function by default. Override it with your own</span>
    <span style='color:#3f7f59; '>// initialization logic.</span>
    <span style='color:#3f7f59; '>// 可自定义initialize方法，默认什么都不做</span>
    initialize: <span style='color:#7f0055; font-weight:bold; '>function</span>(){}

    <span style='color:#3f7f59; '>//...</span>
});
</pre>
									</div>
									<p>在实例化一个Model对象时，首先调用constructor方法，然后在函数的最后调用initialize方法。initialize方法可以在constructor的第一个参数中进行设置。</p>
									<h4>set</h4>
									<p>该方法用来对attributes中的属性进行赋值。</p>
									<div class="code-block">
<pre>_.extend(Model.prototype, Events, {
    <span style='color:#3f7f59; '>//...</span>

    <span style='color:#3f7f59; '>// Set a hash of model attributes on the object, firing `"change"`. This is</span>
    <span style='color:#3f7f59; '>// the core primitive operation of a model, updating the data and notifying</span>
    <span style='color:#3f7f59; '>// anyone who needs to know about the change in state. The heart of the beast.</span>
    <span style='color:#3f7f59; '>// options: unset : 删除对应的属性</span>
    <span style='color:#3f7f59; '>//          silent: 不触发修改属性的change事件</span>
    set: <span style='color:#7f0055; font-weight:bold; '>function</span>(key, val, options) {
      <span style='color:#7f0055; font-weight:bold; '>var</span> attr, attrs, unset, changes, silent, changing, prev, current;
      <span style='color:#7f0055; font-weight:bold; '>if</span> (key == <span style='color:#7f0055; font-weight:bold; '>null</span>) <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>this</span>;

      <span style='color:#3f7f59; '>// Handle both `"key", value` and `{key: value}` -style arguments.</span>
      <span style='color:#3f7f59; '>// 两种形式的参数</span>
      <span style='color:#7f0055; font-weight:bold; '>if</span> (<span style='color:#7f0055; font-weight:bold; '>typeof</span> key === <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>object</span><span style='color:#2a00ff; '>'</span>) {
        attrs = key;
        options = val;
      } <span style='color:#7f0055; font-weight:bold; '>else</span> {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      <span style='color:#3f7f59; '>// Run validation.</span>
      <span style='color:#7f0055; font-weight:bold; '>if</span> (!<span style='color:#7f0055; font-weight:bold; '>this</span>._validate(attrs, options)) <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>false</span>;

      <span style='color:#3f7f59; '>// Extract attributes and options.</span>
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = <span style='color:#7f0055; font-weight:bold; '>this</span>._changing;
      <span style='color:#7f0055; font-weight:bold; '>this</span>._changing  = <span style='color:#7f0055; font-weight:bold; '>true</span>;           <span style='color:#3f7f59; '>//用_changing属性实现对attributes属性的锁，因为Javascript是单线程的，所以不需要原子操作</span>

      <span style='color:#7f0055; font-weight:bold; '>if</span> (!changing) {
        <span style='color:#7f0055; font-weight:bold; '>this</span>._previousAttributes = _.clone(<span style='color:#7f0055; font-weight:bold; '>this</span>.attributes);
        <span style='color:#7f0055; font-weight:bold; '>this</span>.changed = {};
      }
      current = <span style='color:#7f0055; font-weight:bold; '>this</span>.attributes, prev = <span style='color:#7f0055; font-weight:bold; '>this</span>._previousAttributes;

      <span style='color:#3f7f59; '>// Check for changes of `id`.</span>
      <span style='color:#7f0055; font-weight:bold; '>if</span> (<span style='color:#7f0055; font-weight:bold; '>this</span>.idAttribute <span style='color:#7f0055; font-weight:bold; '>in</span> attrs) <span style='color:#7f0055; font-weight:bold; '>this</span>.id = attrs[<span style='color:#7f0055; font-weight:bold; '>this</span>.idAttribute];

      <span style='color:#3f7f59; '>// For each `set` attribute, update or delete the current value.</span>
      <span style='color:#7f0055; font-weight:bold; '>for</span> (attr <span style='color:#7f0055; font-weight:bold; '>in</span> attrs) {
        val = attrs[attr];
        <span style='color:#7f0055; font-weight:bold; '>if</span> (!_.isEqual(current[attr], val)) changes.push(attr);
        <span style='color:#7f0055; font-weight:bold; '>if</span> (!_.isEqual(prev[attr], val)) {
          <span style='color:#7f0055; font-weight:bold; '>this</span>.changed[attr] = val;
        } <span style='color:#7f0055; font-weight:bold; '>else</span> {
          <span style='color:#7f0055; font-weight:bold; '>delete</span> <span style='color:#7f0055; font-weight:bold; '>this</span>.changed[attr];
        }
        unset ? <span style='color:#7f0055; font-weight:bold; '>delete</span> current[attr] : current[attr] = val;
      }

      <span style='color:#3f7f59; '>// Trigger all relevant attribute changes.</span>
      <span style='color:#7f0055; font-weight:bold; '>if</span> (!silent) {
        <span style='color:#7f0055; font-weight:bold; '>if</span> (changes.<span style='color:#7f0055; font-weight:bold; '>length</span>) <span style='color:#7f0055; font-weight:bold; '>this</span>._pending = options;
        <span style='color:#7f0055; font-weight:bold; '>for</span> (<span style='color:#7f0055; font-weight:bold; '>var</span> i = 0, l = changes.<span style='color:#7f0055; font-weight:bold; '>length</span>; i &lt; l; i++) {
            <span style='color:#3f7f59; '>//触发change事件</span>
            <span style='color:#7f0055; font-weight:bold; '>this</span>.trigger(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>change:</span><span style='color:#2a00ff; '>'</span> + changes[i], <span style='color:#7f0055; font-weight:bold; '>this</span>, current[changes[i]], options);
        }
      }

      <span style='color:#3f7f59; '>// You might be wondering why there's a `while` loop here. Changes can</span>
      <span style='color:#3f7f59; '>// be recursively nested within `"change"` events.</span>
      <span style='color:#3f7f59; '>// ??</span>
      <span style='color:#7f0055; font-weight:bold; '>if</span> (changing) <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>this</span>;
      <span style='color:#7f0055; font-weight:bold; '>if</span> (!silent) {
        <span style='color:#7f0055; font-weight:bold; '>while</span> (<span style='color:#7f0055; font-weight:bold; '>this</span>._pending) {
          options = <span style='color:#7f0055; font-weight:bold; '>this</span>._pending;
          <span style='color:#7f0055; font-weight:bold; '>this</span>._pending = <span style='color:#7f0055; font-weight:bold; '>false</span>;
          <span style='color:#7f0055; font-weight:bold; '>this</span>.trigger(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>change</span><span style='color:#2a00ff; '>'</span>, <span style='color:#7f0055; font-weight:bold; '>this</span>, options);
        }
      }
      <span style='color:#7f0055; font-weight:bold; '>this</span>._pending = <span style='color:#7f0055; font-weight:bold; '>false</span>;
      <span style='color:#7f0055; font-weight:bold; '>this</span>._changing = <span style='color:#7f0055; font-weight:bold; '>false</span>;
      <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>this</span>;
    }

    <span style='color:#3f7f59; '>//...</span>
});
</pre>
									</div>
									<p>这是Model模块的一个核心方法，set方法会和Events模块紧密结合，从而实现监听Model中数据变化的机制，以通知视图更新或者更新其他的属性等。</p>
									<h4>fetch</h4>
									<p>该方法用来从服务器获取Model中的数据。</p>
									<div class="code-block">

									</div>
								</div>
							</article>
						</div>