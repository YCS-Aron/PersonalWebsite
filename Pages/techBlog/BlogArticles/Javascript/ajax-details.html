<div class="blog-body">
							<header class="header">
								<div class="title">
									<h1>Ajax详解</h1>
									<p class="subline">Ajax的实现方式和分析,XHR的介绍,同源策略和跨域访问的介绍,以及JSONP的原理</p>
									<p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/5/22</strong></p>
								</div>
							</header>
							<article class="article-content">
								<div>
									<p>Ajax是实现与服务器交互的新方法。Ajax的全称是Asynchronous Javascript And XML，从命名上可以看出，是采用了Javascript的异步机制和XML这两种技术，其中异步机制实现非阻塞的IO，XML来用表示HTTP请求。</p>
									<p>所以，我们需要了解异步Javascript和XML HTTP请求即XmlHttpRequest两个概念。</p>
									<h3>异步Javascript</h3>
									<p>异步是指：程序不会去等待某个费时操作（比如I/O,服务器请求）返回结果，而是继续执行后面的操作，当结果返回时，再转而继续执行定义好的回调函数。Javascript是单线程执行的，它不像Java那样能够支持多线程和并发操作。那么，作为单线程的Javascript就应该尽量让线程不要停下来，否则，整个程序都会陷入“假死”状态。在处理像I/O这样非常费时的操作时，为了获得良好的用户体验，决定了非阻塞I/O的合理性。</p>
									<div class="warning">
										<span>与返回数据相关的操作要放在数据请求的回调函数中，否则数据的可靠性会变得很差。</span>
									</div>
									<p>Javascript有很多优秀的开源库，其中就有不少封装了异步机制的库，比如jQuery的Deferred对象，Q.js，bluebird等。他们在实现异步方面的差异请参考<span class="key-word">Javascript单线程</span>。了解他们在执行顺序上的区别对理解异步有很大的帮助。比如，下面一个例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#3f7f59; '>//用jQuery的Deferred对象</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> cache = {<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>YCS</span><span style='color:#2a00ff; '>'</span>: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>YaoChuansong</span><span style='color:#2a00ff; '>'</span>}
<span style='color:#7f0055; font-weight:bold; '>var</span> getName = <span style='color:#7f0055; font-weight:bold; '>function</span>(nickname) {
	<span style='color:#7f0055; font-weight:bold; '>if</span>(!cache[nickname]) {
		<span style='color:#7f0055; font-weight:bold; '>return</span> cache[nickname];
	} <span style='color:#7f0055; font-weight:bold; '>else</span> {
		<span style='color:#7f0055; font-weight:bold; '>return</span> $.ajax({
			url: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>XXXX</span><span style='color:#2a00ff; '>'</span>,
			method: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>GET</span><span style='color:#2a00ff; '>'</span>
		});
	}
};
getName().then(<span style='color:#7f0055; font-weight:bold; '>function</span>(name) {
	console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>get his name:</span><span style='color:#2a00ff; '>'</span>, name);
});
console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>here is the end of code block</span><span style='color:#2a00ff; '>'</span>);
<span style='color:#3f7f59; '>/* 	OUTPUT:</span>
<span style='color:#3f7f59; '>	get his name YaoChuansong</span>
<span style='color:#3f7f59; '>	here is the end of code block</span>
<span style='color:#3f7f59; '>*/</span>
</pre>
									</div>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#3f7f59; '>//用Q</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> cache = {<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>YCS</span><span style='color:#2a00ff; '>'</span>: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>YaoChuansong</span><span style='color:#2a00ff; '>'</span>}
<span style='color:#7f0055; font-weight:bold; '>var</span> getName = <span style='color:#7f0055; font-weight:bold; '>function</span>(nickname) {
	<span style='color:#7f0055; font-weight:bold; '>if</span>(!cache[nickname]) {
		<span style='color:#7f0055; font-weight:bold; '>return</span> cache[nickname];
	} <span style='color:#7f0055; font-weight:bold; '>else</span> {
		<span style='color:#7f0055; font-weight:bold; '>return</span> Q($.ajax({
			url: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>XXXX</span><span style='color:#2a00ff; '>'</span>,
			method: <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>GET</span><span style='color:#2a00ff; '>'</span>
		}));
	}
};
getName().then(<span style='color:#7f0055; font-weight:bold; '>function</span>(name) {
	console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>get his name:</span><span style='color:#2a00ff; '>'</span>, name);
});
console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>here is the end of code block</span><span style='color:#2a00ff; '>'</span>);
<span style='color:#3f7f59; '>/* 	OUTPUT:</span>
<span style='color:#3f7f59; '>	here is the end of code block</span>
<span style='color:#3f7f59; '>	get his name YaoChuansong</span>
<span style='color:#3f7f59; '>*/</span>
</pre>
									</div>
									<p>jQuery的Deferred对象并不保证执行序列总是异步的，而Q，bluebird则保证所有执行序列总是异步的。</p>
									<h3>XmlHttpRequest</h3>
									<p>XMLHttpRequest最早由Microsoft设计并发布。现在已经是W3C标准的一部分。它用XML格式去表示HTTP请求（那以前是用什么表示的HTTP请求？）。之所以用XML，是利用了XML跨平台的特点。</p>
									<h4>XHR的headers</h4>
									<p>在利用XHR发送一个请求的过程中，需要设置URL，以及对XHR的各个字段进行设置，这些字段将直接影响XHR的执行结果，这些字段包括附带的数据格式，希望服务器返回的数据格式等，用来描述整个HTTP报文。下面是个例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#7f0055; font-weight:bold; '>var</span> xhr;
<span style='color:#7f0055; font-weight:bold; '>if</span> (window.XMLHttpRequest) {
	xhr = <span style='color:#7f0055; font-weight:bold; '>new</span> XMLHttpRequest();
} <span style='color:#7f0055; font-weight:bold; '>else</span> <span style='color:#7f0055; font-weight:bold; '>if</span> (window.ActiveXObject) {
	xhr = <span style='color:#7f0055; font-weight:bold; '>new</span> ActiveXObject(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Microsoft.XMLHTTP</span><span style='color:#2a00ff; '>"</span>);
}
xhr.open(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>get</span><span style='color:#2a00ff; '>'</span>,	<span style='color:#3f7f59; '>//请求的方法</span>
	 <span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>age</span><span style='color:#2a00ff; '>'</span>,	<span style='color:#3f7f59; '>//url</span>
	 <span style='color:#7f0055; font-weight:bold; '>true</span>);	<span style='color:#3f7f59; '>//是否使用异步请求</span>
xhr.setRequestHeader(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Content-type</span><span style='color:#2a00ff; '>"</span>,<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/plain</span><span style='color:#2a00ff; '>"</span>);	<span style='color:#3f7f59; '>//"Content-type" 描述附加数据的类型</span>
xhr.setRequestHeader(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Accept</span><span style='color:#2a00ff; '>"</span>,<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/plain</span><span style='color:#2a00ff; '>"</span>);		<span style='color:#3f7f59; '>//"Accept" 描述希望服务器返回数据的类型</span>
xhr.onreadystatechange = <span style='color:#7f0055; font-weight:bold; '>function</span>(){			<span style='color:#3f7f59; '>//请求成功以后的回调函数</span>
	console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>get his name </span><span style='color:#2a00ff; '>'</span>, xhr.responseText);
};
<span style='color:#3f7f59; '>//发送请求</span>
xhr.send(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>name=aron</span><span style='color:#2a00ff; '>"</span>);
</pre>
									</div>
									<p>HTTP报文的各个header含义如下：</p>
									<ul>
										<li>Content-type：附加数据的数据类型</li>
										<li>Accept：希望服务器返回的数据类型</li>
									</ul>
									<h4>XHR请求的状态码</h4>
									<p>当我们需要了解请求的执行状态时，可以通过XHR的状态码来识别。状态码分为两种，readyState和Status，他们都是XmlHttpRequest对象的两个成员。前者表示XHR的执行情况，如未发送，已发送正在等待服务器答复，服务器已返回等。后者表示服务器的执行状态码，与服务器端的代码执行情况有关。</p>
									<p>readyState状态码</p>
									<ul>
										<li>0：对象未初始化，即没用调用open方法。</li>
										<li>1：请求未发出，即还没有调用send方法。</li>
										<li>2：请求已经发送，服务器正在处理中。</li>
										<li>3：请求已经发送，已经收到了部分返回数据，数据不完整。</li>
										<li>4：请求已经完成，可以读取完整的返回数据。</li>
									</ul>
									<p>Status状态码</p>
									<ul>
										<li>1XX：一些信息状态码，不表示请求成功或者失败。</li>
										<li>2XX：代表正常，其中最常见的200表示一切OK。</li>
										<li>3XX：请求未发出，即还没有调用send方法。</li>
										<li>4XX：客户端错误，如404表示请求文件未找到。</li>
										<li>5XX：服务器端错误。</li>
									</ul>
									<p>所以，如果想得到正确的服务器返回数据，代码需要这么写：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
xhr.onreadystatechange = <span style='color:#7f0055; font-weight:bold; '>function</span>(){
	<span style='color:#7f0055; font-weight:bold; '>if</span>(xhr.readyState === 4 &amp;&amp; xhr.status === 400) {
		console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>It is really succeed.Get </span><span style='color:#2a00ff; '>'</span>, xhr.responseText);
	}
};
</pre>
									</div>
									<h4>XHR的数据解析</h4>
									<p>XHR有不同的发送请求的方法，包括GET,POST,HEAD等。在使用GET或者POST时，我们可以通过给send传递一个参数为请求附加数据，参数的类型是任意的。</p>
									<p>一般来说，GET请求是用来请求数据的，比如请求用户信息等。GET请求的数据是附加在URL上的，这样就使得附加的数据很透明，不够安全。POST请求通常是用来向服务器上存数据，或者要求服务器进行某个操作，客户端只需要了解操作的状态，比如删除一个文件，客户端只需要知道删除成功或者失败即可。POST请求的数据是放在header中的。（具体是怎么放的？格式？字段？）</p>
									<p>我们可以从XHR的responseText中获取数据的字符串形式，然后解析成我们需要的数据类型？？？。在使用jQuery发送Ajax请求时，会设置Accept字段，该字段定义了希望服务器返回的数据的类型。jQuery会自动的将responseText转化为对应的Accept字段描述的类型，然后直接通过异步回调函数的参数获取转换后的数据。字符串，JSON很好处理，可以直接操作。XML的解析有点复杂，下面是一段解析的代码：</p>
									<div class="code-block">
<pre>xmltext=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;note></span><span style='color:#2a00ff; '>"</span>;
xmltext+=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;to>George&lt;/to></span><span style='color:#2a00ff; '>"</span>;
xmltext+=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;from>John&lt;/from></span><span style='color:#2a00ff; '>"</span>;
xmltext+=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;heading>Reminder&lt;/heading></span><span style='color:#2a00ff; '>"</span>;
xmltext+=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;body>Don't forget the meeting!&lt;/body></span><span style='color:#2a00ff; '>"</span>;
xmltext+=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>&lt;/note></span><span style='color:#2a00ff; '>"</span>;
<span style='color:#7f0055; font-weight:bold; '>try</span> <span style='color:#3f7f59; '>//Internet Explorer</span>
{
    xmlDoc=<span style='color:#7f0055; font-weight:bold; '>new</span> ActiveXObject(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Microsoft.XMLDOM</span><span style='color:#2a00ff; '>"</span>);
    xmlDoc.async=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>false</span><span style='color:#2a00ff; '>"</span>;
    xmlDoc.loadXML(xmltext);
}
<span style='color:#7f0055; font-weight:bold; '>catch</span>(e)
{
    <span style='color:#7f0055; font-weight:bold; '>try</span> <span style='color:#3f7f59; '>//Firefox, Mozilla, Opera, etc.</span>
    {
        parser=<span style='color:#7f0055; font-weight:bold; '>new</span> DOMParser();
        xmlDoc=parser.parseFromString(xmltext,<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/xml</span><span style='color:#2a00ff; '>"</span>);
    }
    <span style='color:#7f0055; font-weight:bold; '>catch</span>(e)
    {
        <span style='color:#7f0055; font-weight:bold; '>alert</span>(e.message);
        <span style='color:#7f0055; font-weight:bold; '>return</span>;
    }
}
console.<span style='color:#7f0055; font-weight:bold; '>log</span>( xmlDoc.getElementsByTagName(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>to</span><span style='color:#2a00ff; '>"</span>)[0].childNodes[0].nodeValue );
console.<span style='color:#7f0055; font-weight:bold; '>log</span>( xmlDoc.getElementsByTagName(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>from</span><span style='color:#2a00ff; '>"</span>)[0].childNodes[0].nodeValue );
console.<span style='color:#7f0055; font-weight:bold; '>log</span>( xmlDoc.getElementsByTagName(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>body</span><span style='color:#2a00ff; '>"</span>)[0].childNodes[0].nodeValue );
<span style='color:#3f7f59; '>//jQuery</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> xmlDoc = $.parseXML( xmltext );
<span style='color:#7f0055; font-weight:bold; '>var</span> $xml = $( xmlDoc );
console.<span style='color:#7f0055; font-weight:bold; '>log</span>($xml.find( <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>to</span><span style='color:#2a00ff; '>"</span> ));
console.<span style='color:#7f0055; font-weight:bold; '>log</span>($xml.find( <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>from</span><span style='color:#2a00ff; '>"</span> ));
console.<span style='color:#7f0055; font-weight:bold; '>log</span>($xml.find( <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>body</span><span style='color:#2a00ff; '>"</span> ));
</pre>
									</div>
									<h3>同源策略</h3>
									<p>每个浏览器都有一个URL，比如www.yaochuansong.com/index.html。其中的www.yaochuansong.com就决定了当前页面的域，Javascript只能访问同一域名下的内容，从而避免了一些错误，也提高了安全性。同源策略就是将页面请求限制在自身页面所在的域内。</p>
									<h3>跨域访问</h3>
									<p>在实际开发中，会有一些需求，需要我们去请求另一个域，比如在在线支付过程中，我们需要使用银行的支付接口，也就要向银行的服务器发送请求。这个过程就是跨域访问。</p>
									<h4>JSONP</h4>
									<p>跨域访问的最简单的实现方法是让客户端发送请求给自身域的服务器，让服务器进作为代理转发请求给第三方服务器，这样就绕开了浏览器的同源策略的限制。另一种方法是插入动态脚本，利用<span class="key-word">同源策略不阻止script标签加载动态脚本</span>这一特性，通过script标签的src属性去加载跨域服务器上的数据，这种技术就是<span class="key-word">JSONP</span>。下面是一个例子：</p>
									<div class="code-block">
<pre><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>html</span><span style='color:#7f0055; '>></span>
<span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>head</span><span style='color:#7f0055; '>></span>
	<span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>script</span> type=<span style='color:#2a00ff; '>"text/javascript"</span><span style='color:#7f0055; '>></span>
		<span style='color:#7f0055; font-weight:bold; '>function</span> jsonpCallback = <span style='color:#7f0055; font-weight:bold; '>function</span>(result) {
			console.<span style='color:#7f0055; font-weight:bold; '>log</span>(result);
		}
	<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>script</span><span style='color:#7f0055; '>></span>
	<span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>script</span> type=<span style='color:#2a00ff; '>"text/javascript"</span> src=<span style='color:#2a00ff; '>"http://crossdomain.com/services.php?callback=jsonpCallback"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>script</span><span style='color:#7f0055; '>></span>
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>head</span><span style='color:#7f0055; '>></span>
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>html</span><span style='color:#7f0055; '>></span>
</pre>
									</div>
									<div class="warning">
										<span>Warning: 由于是解释性语言，要注意回调函数的定义要在远程脚本加载之前。</span>
									</div>
									<p>服务器端代码如下：</p>
									<div class="code-block">
	<pre><span style='color:#7f0055;  '>&lt;?php</span><span style='color:#000000;  '>  </span>
<span style='color:#3f7f59;  '>//服务端返回JSON数据  </span><span style='color:#000000;  '></span>
<span style='color:#000000;  '>$arr</span><span style='color:#000000;  '>=</span><span style='color:#7f0055;  font-weight:bold; '>array</span><span style='color:#000000;  '>(</span><span style='color:#2a00ff;  '>'a'</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>></span><span style='color:#000000;  '>1</span><span style='color:#000000;  '>,</span><span style='color:#2a00ff;  '>'b'</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>></span><span style='color:#000000;  '>2</span><span style='color:#000000;  '>,</span><span style='color:#2a00ff;  '>'c'</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>></span><span style='color:#000000;  '>3</span><span style='color:#000000;  '>,</span><span style='color:#2a00ff;  '>'d'</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>></span><span style='color:#000000;  '>4</span><span style='color:#000000;  '>,</span><span style='color:#2a00ff;  '>'e'</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>></span><span style='color:#000000;  '>5</span><span style='color:#000000;  '>)</span><span style='color:#000000;  '>;</span><span style='color:#000000;  '>  </span>
<span style='color:#3f7f59;  '>//将数据组装成JSON格式</span><span style='color:#000000;  '></span>
<span style='color:#000000;  '>$result</span><span style='color:#000000;  '>=</span><span style='color:#7f0055;  font-weight:bold; '>json_encode</span><span style='color:#000000;  '>(</span><span style='color:#000000;  '>$arr</span><span style='color:#000000;  '>)</span><span style='color:#000000;  '>;</span><span style='color:#000000;  '>  </span>
<span style='color:#3f7f59;  '>//获得回调函数名</span><span style='color:#000000;  '></span>
<span style='color:#000000;  '>$callback</span><span style='color:#000000;  '>=</span><span style='color:#000000;  '>$_GET</span><span style='color:#000000;  '>[</span><span style='color:#2a00ff;  '>'callback'</span><span style='color:#000000;  '>]</span><span style='color:#000000;  '>;</span><span style='color:#000000;  '></span>
<span style='color:#3f7f59;  '>//组装Javascript代码段  </span><span style='color:#000000;  '></span>
<span style='color:#7f0055;  font-weight:bold; '>echo</span><span style='color:#000000;  '> </span><span style='color:#000000;  '>$callback</span><span style='color:#000000;  '>.</span><span style='color:#2a00ff;  '>"(</span><span style='color:#2a00ff;  '>$result</span><span style='color:#2a00ff;  '>)"</span><span style='color:#000000;  '>;</span><span style='color:#000000;  '> </span>
<span style='color:#7f0055;  '>?></span>
</pre>
									</div>
									<p>JSONP使得跨域访问成为可能，能够实现在一个页面中使用多种服务，比如旅游网站的地图显示等。当今互联网新出现的<span class="key-word">Mashup</span>,JSONP就是构建Mashup的主要技术。</p>
									<p>JSONP涉及到两个方面，一个是如何将请求发送出去，这一点是利用了同源策略不阻止script标签加载动态脚本这一特性；另一个是如何从script标签中获得跨域请求返回的数据，这一点是通过让跨域服务器返回js文档，该文档会执行回调函数并将请求的数据作为参数，这样就可以在客户端定义的回调函数中处理请求的数据了。下面是JSONP工作的流程：</p>
									<ol>
										<li>客户端定义script标签，将script标签的src属性设置为跨域请求的URL，并将回调函数的函数名作为参数附加到URL上。</li>
										<li>客户端执行script标签，成功发送出跨域访问的请求。</li>
										<li>服务器端在接收到该请求时，先将请求的数据组装成一个JSON对象。<span class="key-word">使用JSON对象的原因是要将其作为Javascript回调函数的参数。</span></li>
										<li>获取参数中的回调函数名，并将其与JSON对象组装成一个Javascript文档，即一段Javascript代码，并返回该文档给客户端。</li>
										<li>客户端获得跨域服务器返回的数据，由于是从script标签中加载的，客户端会执行该Javascript代码。</li>
										<li>客户端定义的回调函数被执行，其中参数就是要请求的跨域服务器数据</li>
									</ol>
									<p>但是JSONP不是一种标准的技术，在使用过程中我们仍然需要注意一些问题。JSONP的请求不会返回服务器状态，远程只是返回一段Javascript执行代码。同时JSONP还存在着一些安全问题，由于执行的是跨域服务器返回的Javascript代码段，如何被一些非信任的跨域服务器返回一些攻击性代码，客户端也只能默默的执行，Web应用程序的安全受到了威胁。</p>
									<h3>利用XHR发送请求的详细过程</h3>
								</div>
							</article>
						</div>