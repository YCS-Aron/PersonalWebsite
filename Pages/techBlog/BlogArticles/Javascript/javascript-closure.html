<div class="blog-body">
							<header class="header">
								<div class="title">
									<h1>Javascript闭包</h1>
									<p class="subline">对Javascript闭包以及相关的域的理解</p>
									<p class="blog-time"><strong>姚川松</strong> &#8212; 写于 <strong>2015/5/16</strong></p>
								</div>
							</header>
							<article class="article-content">
								<div>
									<p>闭包是一种语言特性，很多的语言都支持闭包，其中就包括Javascript。</p>
									<p>在面向对象的软件设计中，如果我们需要定义一种类B，这种类属于某个类A，它可以访问类A的私有数据，并且只有在类中才能够使用类B，那么这里的类B就是我们说的闭包。闭包是指：在类的内部定义内部类，从而实现在内部类中访问外部类的数据，而且该内部类对外是不可见的。</p>
									<p>Javascript支持闭包，但是由于在Javascript中函数既是对象的特点，而且其面向对象的机制与一般的OO语言有很大差异，以及Javascript对域的不同定义，导致了闭包在Javascript中的特殊表现形式。可以理解为：<span class="key-word">Javascript中函数就是闭包。</span></p>
									<h3>Javascript中闭包的作用</h3>
									<p>主要体现在两点：实现数据封装，传递操作</p>
									<h3>数据封装</h3>
									<p>函数即闭包，函数即对象，在Javascript的面向对象编程中，通过闭包可以实现数据的封装。下面是一个例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#7f0055; font-weight:bold; '>var</span> person = <span style='color:#7f0055; font-weight:bold; '>function</span>(n) {
    <span style='color:#7f0055; font-weight:bold; '>var</span> name = n;   <span style='color:#3f7f59; '>//这里的name只能通过返回的闭包进行读取</span>
    <span style='color:#7f0055; font-weight:bold; '>return</span> {
        getName: <span style='color:#7f0055; font-weight:bold; '>function</span>() {
            <span style='color:#7f0055; font-weight:bold; '>return</span> name;
        }
    }
};
<span style='color:#7f0055; font-weight:bold; '>var</span> personA = person(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>Tim</span><span style='color:#2a00ff; '>'</span>);  <span style='color:#3f7f59; '>//personA实质是一个JSON对象</span>
</pre>
									</div>
									<p>这样我们就实现了外部对内部数据访问权的控制。而且这里的person具有重用性，每次调用都将返回一个全新的JSON，并能访问不同内存单元的name属性。</p>
									<h3>传递操作</h3>
									<p>将要执行的回调函数即闭包作为参数传递给接口，此时闭包拥有定义该闭包时的上下文。下面是一个例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#7f0055; font-weight:bold; '>var</span> buttons = $(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>button.a</span><span style='color:#2a00ff; '>'</span>);
<span style='color:#7f0055; font-weight:bold; '>for</span>(<span style='color:#7f0055; font-weight:bold; '>var</span> i = 0; i &lt; buttons.<span style='color:#7f0055; font-weight:bold; '>length</span>; i++) {
    buttons.eq(i).on(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>click</span><span style='color:#2a00ff; '>'</span>, <span style='color:#7f0055; font-weight:bold; '>function</span>(e) {
        console.<span style='color:#7f0055; font-weight:bold; '>log</span>(i);
    });
}
</pre>
									</div>
									<p>这是网上使用得比较多的一个例子。看代码的意思是，点击button时，输出该button的索引值。而实际情况是无论点哪个都显示同一个值，而且值为最大索引值加1。这是因为每次传递的闭包的上下文环境一样，导致了每个闭包中的i都指向了同一块内存空间的变量i，即循环中的变量i。改进后的代码如下：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#7f0055; font-weight:bold; '>var</span> buttons = $(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>button.a</span><span style='color:#2a00ff; '>'</span>);
<span style='color:#7f0055; font-weight:bold; '>for</span>(<span style='color:#7f0055; font-weight:bold; '>var</span> i = 0; i &lt; buttons.<span style='color:#7f0055; font-weight:bold; '>length</span>; i++) {
    buttons.eq(i).on(<span style='color:#2a00ff; '>'</span><span style='color:#2a00ff; '>click</span><span style='color:#2a00ff; '>'</span>, (<span style='color:#7f0055; font-weight:bold; '>function</span> generateCallback(i) {
        <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>function</span>(e) {
            console.<span style='color:#7f0055; font-weight:bold; '>log</span>(i);
        }; 
    })(i));
}
</pre>
									</div>
									<p>改进后的代码，每次都执行一个函数，改函数以循环变量i为参数，返回的闭包的上下文是generateCallback，而每次generateCallback执行时变量i都是不同的，因此满足需求。实际上，在返回的闭包中任然有循环变量i的访问权，只是因为重名被函数参数给覆盖了。</p>
									<h3>使用闭包需要注意的问题</h3>
									<h3>域的问题</h3>
									<p>就像上面的例子，如果对闭包的理解不当，就会导致访问错误的数据。因此，在使用闭包时，要清楚该闭包能够访问的数据范围。具体请参考<span class="key-word">域链(scope chain)</span></p>
									<h3>内存效率</h3>
									<p>闭包对于内存管理非常重要。由于闭包牵涉到定义闭包的上下文，因此，当定义的闭包存在并且在内存中有效时（即在垃圾回收过程中，总是能遍历和标记到该闭包），其牵涉的父域也将被标记为非垃圾。所以，当使用闭包时，会给内存带来一定的压力。当使用不当时，比如出现循环引用时，会导致内存泄露。下面给个导致内存泄露的例子：</p>
									<div class="code-block">
<pre><html><body style='color:#000000; background:#ffffff; '><pre>
<span style='color:#7f0055; font-weight:bold; '>function</span>() {
    <span style='color:#7f0055; font-weight:bold; '>var</span> objA = {};
    objA.attr = <span style='color:#7f0055; font-weight:bold; '>function</span>() {
        <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>false</span>;
    }
}
</pre>
									</div>
									<p>表面看起来好像没有什么问题，仔细分析后会发现objA.attr指向了一个闭包，而该闭包的可访问域是包含了objA这个值的，也就是说行成了一个环状引用，当其它地方没用引用到这两个数据时，垃圾回收机制将无法正常回收这两个数据。这个问题在IE中是存在的。在Chrome和Firefox等浏览器中，可能会在优化阶段对其进行处理。</p>
									<p><strong>引用<a href="http://www.zhihu.com/question/22806887/answer/22720735">Javascript闭包都会导致内存泄露吗</a></strong></p>
								</div>
							</article>
						</div> <!-- blog-body -->