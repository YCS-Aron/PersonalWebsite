<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>jQuery事件机制</h1>
            <p class="subline">jQuery事件机制详解</p>
            <p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/5/22</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>jQuery的一个重要部分就是事件机制，通过事件机制我们可以实现UI的实时更新等很多前端的特征。</p>
            <p>jQuery实现事件绑定的方法bind,on,live,delegate四种方法。下面需要了解下这四种绑定方式的区别。</p>
            <h2>bind</h2>
<pre><code class="javascript">$('.myclass').bind('click', function() {
    //code...
});
$('.myclass').click(function() {	//平时我们用的click,focus等绑定方法是bind方法的一个简写
    //code...
});</code></pre>
            <p>直接绑定响应函数到元素上。这种方法简单直接，在各种浏览器中都能兼容。但是，<span class="key-word">这种方法非常不适合动态元素的绑定</span>，当需要对一个元素下的所有子元素都绑定同一个响应函数时，而且这些子元素是动态的，会随时添加和被删除，那么我们就需要维护所有子元素的绑定事件，当添加子元素时，还需要手动的去添加，非常费时。</p>
            <h2>live</h2>
<pre><code class="javascript">$('.myclass').live('click', function() {
    //code...
});
$(document).on('click', function(e) {
    if(e.target.className.indexOf('myclass') > -1) {
        //code...
    }
});</code></pre>
            <p>live是将事件的响应绑定到根元素即document上，其所有的子元素上的事件都会通过<span class="code-block">冒泡</span>传递到document上，document再通过获取事件的类型和元素来决定执行哪个响应函数，这就是<span class="code-block">事件委托</span>。live可以很好的解决动态元素的事件绑定问题，无需在添加新元素时去管理新元素的事件绑定。通过这种方式我们可以写最少的代码，做最多的事情，但是性能上会有些损失，尤其是子元素在DOM树中处于很深的位置时，而且，因为必须要到达根元素，该事件的<span class="key-word">stopPropagation</span>无效。</p>
            <p>live不够灵活，不推荐采用这种方法绑定事件。</p>

            <h2>delegate</h2>
<pre><code class="javascript">$('.myclass').delegate('button', 'click', function() {
    //code...
});
$('.myclass').on('click', function(e) {
    if(e.target.tagName === "button") {
        //code...
    }
});</code></pre>
            <p>该方式不再将事件处理委托给document，而是由coder决定委托的元素。这个例子中，委托元素是$('.myclass')，要监听的元素是$('.myclass button')。自定义委托元素，十分灵活。</p>
            <p></p>

            <h2>on</h2>
            <p>首先来看一下on的声明格式。</p>
<pre><code class="javascript">jQuery.fn.extend({
    //...

    //types: 	当绑定单个事件是单个事件名的字符串;当绑定多个事件时是多个事件名用空格隔开的字符串;当通过JSON对象绑定时是事件名和响应函数的映射，比如$('XXX').on({click: function(){}})
    //selector: delegate中的子元素selector
    //data:     绑定的数据，可以在响应函数中通过e.data访问(假设第一个参数名为e)
    //fn        响应函数，会有一个参数用来接收event对象
    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        //...
    },

    //..
});</code></pre>
            <p>该方法是jQuery 1.7之后添加的统一事件绑定的接口。通过on可以实现bind, live, delegate方法，事实上jQuery也就是这么做的。代码如下：</p>
<pre><code class="javascript">jQuery.fn.extend({
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
    }
});</code></pre>
            <p>bind是最简单和快速的事件绑定方式，但是灵活性比较差，不适合动态元素；live将事件的处理放在了根元素document上，通过判断事件的类型和促发事件的元素的属性来选择响应的处理函数；delegate是live的改进版，可以自定义委托元素，从而提供了灵活性，也减少了事件冒泡的路径长度，提高了性能；on作为一个最新版本的通用的事件绑定方法，提供了方便的接口。</p>
            <p><strong>Reference: <a onclick="window.open('http://elijahmanor.com/differences-between-jquery-bind-vs-live-vs-delegate-vs-on/');">differences between jquery bind vs live vs delegate vs on</a></strong></p>
        </div>
    </article>
</div>