<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>Javascript语言特性</h1>
            <p class="subline">对Javascript语言特性的认识</p>
            <p class="blog-time"><strong>姚川松</strong> &#8212; 写于 <strong>2015/3/21</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>在google对ajax广泛使用的背景下, Javascript从一个只被用来在浏览器上操作DOM的脚本语言, 成为了最热门的语言之一, 随着Javascript的发展, 用Javascript编写的开源框架和库越来越多: Backbone, Angular, jQuery, Underscore, Handlebars, Q等等, 使其成为了Github上被用来编写开源项目最多的语言. </p>
            <p>目前几乎所有浏览器厂商都采用Javascript实现各自浏览器的对外接口,比如DOM和BOM, 并且几乎所有的浏览器都内置了Javascript引擎,所以,只需要打开浏览器,在控制栏里直接输入Javascript代码就能运行。Javascript拥有很多独特的语言特性,使得它成为一门非常与众不同的语言, 并让Javascript这门语言变得非常的有趣, 同时, 也是因为它与众不同的特性, 使得它成为争议最多的语言。</p>
            <p>Javascript的语言特性主要有：宽松数据类型, 函数即对象, 函数作用域, 变量提升, 闭包, 原型概念, 单线程.</p>
            <h2>宽松类型</h2>
            <p>Javascript是<span class="key-word">弱类型</span>语言，统一使用关键字<span class="key-word">var</span>定义数据,而无需指定具体的数据类型。这使得它和C++, Java这样的数据类型检查严格的语言有很大的不同。宽松数据类型的特性一方面让程序员可以“偷懒”, 另一方面也给程序的稳定性带来一定的隐患, 因为不同的数据类型对应的相同操作的含义是不一样的. 比如定义了一个计算两个数值相加的add函数, 如果我传入字符串, 依旧可以运行, 但是结果却不是我想要的, 这就使得程序变得不那么可靠，或者你需要在操作变量之前先检查变量类型是否正确和是否具有操作性，比如下面的代码：</p>
            <pre><code class="javascript">
var add = function (a, b) { //定义一个加法功能的函数
    return a + b;
};
add(1,2);               //应该这么调用，返回值是3
add('hello world',2);   //如果不小心传入了一个字符串，函数能正常执行，返回值是"hello world2"，在C++中也由同样的结果，两者没有什么差别
add();                  //又一个不小心，传入了两个undefined，它竟然奇迹般的不报错，还给你正经的返回一个NaN，
add({attr: 'nihao'}, 1); //传入了一个JSON对象，结果为1

var correctAdd = function(a, b){
    if(typeof(a) === 'number' && typeof(b) === 'number') {
        return a + b;
    } else {
        throw new Error('incorrect operand type!');
    }
}
            </code></pre>
            <p>正因为类型的灵活性，让Javascript有了很大的自由性, 但是却牺牲了可靠性, 这就需要Coder自己检查数据合法性, 以满足可靠性. 也就是说, 定义类型的时候方便了, 也就意味着使用时要小心翼翼, 如果还不放心, 就多写一些类型检查代码吧. </p>
            <p>Javascript的弱类型和脚本语言的特点, 使得它在开发大型系统时的可靠性受到了质疑. 它不像Java那样可以在编译阶段就检查出很多的类型错误, 通过数据类型限制了错误的发生, 保证了程序的可靠性, 这也就是Java的数据类型丰富并且拥有泛型的原因. 但是, 也是因为Javascript的弱类型, 使得Javascript代码比Java代码要简洁得多而且灵活得多, Coder可以把更多的精力放在代码逻辑上, 而不是数据类型的定义和处理上, 着实解放了程序员.</p>
            <h2>函数即对象</h2>
            <p>在Javascript中定义一个函数, 解释器会生成一个该函数对应的对象, 该对象中的属性包括Object对象的prototype对象上的属性和constructor, 该对象只是一个普通的JSON对象, 你可以给它绑定任何数据. 作为普通函数, 它可以直接调用, 如果希望通过函数来实现抽象类, 那么你需要在函数体中使用<span class="key-word">this对象</span>, 并从函数中不返回任何数据. 如果你使用了this, 那么你可能又需要<span class="key-word">new调用方式</span>, 它和<span class="key-word">prototype</span>一起实现了类的抽象, 当使用new调用方式时, 函数会返回this对象作为实例化的结果. 当我们需要实现抽象时. 即为每个实例对象都绑定指定固有属性的引用, 那么需要给函数对象绑定prototype对象. prototype对象中还用__proto__属性引用了继承对象的prototype对象. 下面是一段使用函数实现类的例子: </p>
            <pre><code class="javascript">
var myobj = function(name){
    this.name = name;
    console.log('this is contructor');
};
myobj.prototype.getInfo = function(){
    console.log('my name is ', this.name);
};
myobj.publicName = 'Aron';
myobj();                        //output: this is contructor    这条语句不返回任何值
var obj = new myobj('ycs');     //output: this is contructor
obj.getInfo();                  //output: my name is ycs
console.log(myobj.publicName);  //output: Aron
            </code></pre>
            <h2>函数作用域</h2>
            <p>Javascript是<span class="key-word">函数作用域</span>, 因此它不像Java, C++那样可以在if, while等语句块中重新生成一个数据域. 函数域中依旧可以访问到定义该函数的函数作用域, 因为当前域中保存了对上层作用域的引用, 因此上下函数作用域相互之间的结构是链的结构, 最顶层是全局作用域. 在函数作用域和变量提升的影响下, 我们需要在编写代码的过程中注意要将变量定义在函数域的顶部.</p>
            <p>定义一个函数, 也意味着新建了一个数据作用域, 该作用域中定义的数据不会影响到上层作用域中的数据. 这个特性实现了Javascript的模块. Javascript中模块就是一个函数对象.</p>
            <h2>变量提升</h2>
            <p>在Java, C++中, 声明变量的推荐方式是什么时候用就什么时候声明, 由于函数作用域的特性, 在Javascript中声明变量的方式有点特别. </p>
            <p>变量提升的表现形式是: 在函数体中的所有声明变量的语句的声明部分都会被提升到所在函数域的顶部. 原因一方面是Javascript是函数作用域, 变量提升后的效果是一样的, 另一方面是希望通过变量提升避免一些问题, 比如重复声明. 我觉得提升后的代码比未提升的代码性能要高, 变量提升应该也算是一种优化方式. </p>
            <h2>闭包</h2>
            <p>闭包是指在对象内部定义一个语句块, 该语句块能够访问到该对象的数据作用域, 并且该语句块可以传递到对象外供其他对象使用, 也就是从对象内部传递出一个能够操作该对象内部数据的逻辑. 闭包是编程语言设计中的一个概念, 它在不同的语言中的实现方式由编程语言的语言特性决定. 现在很多语言都支持闭包, Java通过Lambda表达式实现闭包, Javascript则通过函数. </p>
            <p>闭包挑战了访问域，挑战了垃圾回收机制，实际上Javascript的所有函数都是一个闭包。闭包可以使得代码块（一般是以匿名函数形式的形式）能像变量一样在程序中进行传递, 实际上在Javascript中传递的闭包是一个函数对象. 因为闭包是函数对象,所以闭包拥有定义该闭包的函数的数据作用域的访问权，由于涉及到函数作用域链, 而<span class="key-word">垃圾回收</span>又是根据作用域链来寻找垃圾对象的, 所以闭包对内存的影响非常大. 闭包拥有定义该闭包的函数的数据作用域, 因此, 只要该闭包还存在正常饮用, 那么定义该闭包的函数的数据作用域就永远不会被回收, 增加了内存的占用. 闭包在使用不当的情况下, 甚至会导致内存泄露, 比如下面的代码: </p>
            <pre><code class="javascript">
function fun(){
    var dom = document.createElement(".test-mem-leak");
    dom.onclick = function(){ return false;}
}
            </code></pre>
            <p>上面的例子中, 如果垃圾回收机制采用<span class="key-word">引用计数</span>, 那么dom对象和onclick对应的闭包的引用数都至少为1, 所以如果这个dom对象没有加到DOM树中, 那么必然产生了内存泄露. 如果采用<span class="key-word">标记清扫</span>或者<span class="key-word">分代回收</span>则不会产生内存泄露, 恰好, 低版本的IE的DOM对象的垃圾回收采用了引用计数机制. 即在IE下会产生内存泄露, 而其他浏览器不会.</p>
            <h2>原型(prototype)</h2>
            <p>原型是Javascript引入的用来实现抽象类的特征之一. 它和this对象, new调用方法一起实现了Javascript中的抽象类. prototype是函数对象上的一个属性, 类型是一个对象, 该对象上的值包括: constructor, __proto__, 用户自定义的属性. 这些属性有着特殊的含义. 在为函数对象设置prototype属性后, 并且在用new调用方法调用函数时, 函数体中的this对象的初始值包含了prototype对象上的属性的<span class="key-word">引用</span>. 从而达到了每个实例对象都共享同一份数据的目的. 下面是一个例子:</p>
            <pre><code class="javascript">
var myobj = function(){
    if(this.getInfo) {
        console.log('getInfo already exist in contructor');
    }
    if(this.getInfo === myobj.prototype.getInfo) {
        console.log('getInfo method is a reference of getInfo of prototype');
    }
};
myobj.prototype.getInfo = function(){
    console.log('this is getInfo');
};
var obj = new myobj();
obj.getInfo();
//output: getInfo already exist in contructor
//output: getInfo method is a reference of getInfo of prototype
//output: this is getInfo
            </code></pre>
            <p>prototype对象上的属性很大程度的决定了在通过new关键字实例化时this对象的初始值.</p>
            <h2>单线程的执行方式</h2>
            <p>单线程是Javascript的一个重要特性。Javascript不像Java那样支持多线程. Javascript代码分为<span class="key-word">异步</span>和<span class="key-word">同步</span>两种执行方式。同步方式是指代码总是去等待当前任务执行结束, 再去执行下一个任务, 也就是一般的程序执行流程。异步方式是指当一个任务遇到I/O阻塞时, 它会先去执行后面的代码, 等到之前的I/O操作完成之后再回来继续执行未完成的任务, 具体执行的时机还需要了解Javascript的<span class="key-word">事件轮询</span>机制。一般来说, 异步主要是用于事件触发, 发ajax请求, 有时还用于模块加载. 异步用的最多的还是ajax请求相关的代码.</p>
            <p><span class="key-word">setTimeout</span>是经常会用到的控制执行流程的方法, 但是也会带来一些负作用, 因为Coder也不清楚异步任务什么时候能够执行结束. 在控制ajax相关的代码执行流程方面, 应该尽量用<span class="key-word">Promise</span>, 目前有很多开源的Promise的实现, 比如jQuery中的Deferred对象, Q, Bluebird等等，当然，不同的Promise实现在流程控制上也是有差别的。</p>

            <!--<p><strong>Excerpt from: <a href="http://www.gutenberg.org/ebooks/15237">The Chemistry of Food and Nutrition</a> by A. W. Duncan</strong></p>-->
        </div>
    </article>
    <div class="content-box" style="margin-bottom: 200px;">
        <h3 class="content-box-header bg-blue text-left">
            <i class="glyph-icon icon-comments"></i>
            评论
        </h3>
        <div class="content-box-wrapper">

            <ul class="chat-box">
                <li class="float-left">
                    <div class="chat-author">
                        <img width="36" src="../../assets/image-resources/gravatar.jpg" alt="">
                    </div>
                    <div class="popover right no-shadow">
                        <div class="arrow"></div>
                        <div class="popover-content">
                            <h3>
                                <a href="#" title="Horia Simon">Horia Simon</a>
                                <div class="float-right">
                                    <a href="#" class="btn glyph-icon icon-inbox font-gray tooltip-button" data-placement="bottom" title="" data-original-title="This chat line was received in the mail."></a>
                                </div>
                            </h3>
                            This comment line has a title (author name) and a right button panel.
                            <div class="chat-time">
                                <i class="glyph-icon icon-clock-o"></i>
                                a few seconds ago
                            </div>
                        </div>
                    </div>
                </li>
                <li>
                    <div class="chat-author">
                        <img width="36" src="../../assets/image-resources/gravatar.jpg" alt="">
                    </div>
                    <div class="popover left no-shadow">
                        <div class="arrow"></div>
                        <div class="popover-content">
                            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec odio. Quisque volutpat mattis eros. Nullam malesuada erat ut turpis. Suspendisse urna nibh, viverra non, semper suscipit, posuere a, pede.
                            <div class="chat-time">
                                <i class="glyph-icon icon-clock-o"></i>
                                a few seconds ago
                            </div>
                        </div>
                    </div>
                </li>
            </ul>

        </div>
        <div class="button-pane pad10A">
            <div class="input-group">
                <input type="text" placeholder="Say something here..." class="form-control">
                <div class="input-group-btn">
                    <button type="button" class="btn btn-default" tabindex="-1"><i class="glyph-icon icon-mail-reply"></i></button>
                    <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" tabindex="-1" aria-expanded="false">
                        <span class="caret"></span>
                        <span class="sr-only">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu pull-right" role="menu">
                        <li><a href="#">Action</a></li>
                        <li><a href="#">Another action</a></li>
                        <li><a href="#">Something else here</a></li>
                        <li class="divider"></li>
                        <li><a href="#">Separated link</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div> <!-- blog-body -->