<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>NodeJS的模块</h1>
            <p class="subline">NodeJS实现模块的方法和原理</p>
            <p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/6/27</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>当采用NodeJS编写后端服务器代码时,不可避免的一个问题就是如何组织代码, 如何将代码模块化, 只要涉及到工程就必然涉及到如何组织模块. 模块化是为了能够让业务逻辑进行分离, 各个模块完成独立的服务器任务, 对于维护和扩展代码都有非常大的作用.下面将介绍如何在Node环境中组织自己的后台模块.</p>
            <p>Node环境实际上就是Javascript环境, 所以, 我们可以从前端Javascript的模块管理中摸索出一些相似的地方.在Javascript前端的模块管理方式中, 模块往往是一个js文件, js文件为代码创造了一个独立的数据域, 从而避免污染上层数据域, 该模块的内容是module变量上的exports属性对应的内容. 而在Node环境下, 模块可以是一个js文件, 也可以是一个文件夹. Node还可以引入npm(Node Package Manager)中已经发布的模块. 在加载顺序上, Node下的模块和前端Javascript模块也有不同.</p>
            <h2>module.exports</h2>
            <p>Node的模块系统利用<span class="key-word">闭包</span>的特性, 将每个模块对应的文件都放在一个独立的数据域中执行, 从而保证了模块中不污染全局数据域(若不放在闭包中, Javascript引擎会将其放在全局数据域中执行), 而且会从闭包中返回module.exports数据. 所以, 当你想自己写一个比如字符串处理的模块时, 可以创建一个js文件, 代码如下:</p>
<pre><code class="javascript">
var commonPrefix = 'String: ';
module.exports = {
    addPrefix: function(str){
        return str + commonPrefix;
    },

    ConvertToUpperCase: function(str){
        return str.toUpperCase();
    },

    //..
}
</code></pre>
            <p>通过指定module.exports的值可以将模块定义为一个包含数据的对象, 静态JSON数据, 或者仅仅一个简单的函数. </p>
            <p>Node中的模块还可以是一个文件夹, 当模块是文件夹时, 系统会从文件夹的根目录中查找<span class="key-word">index.js</span>文件, 将该文件作为入口从中获取module.exports的值. 我们可以将只和该模块有关的子模块或者数据放在该文件夹中指定目录中, 从而方便文件的管理. 比如, 定义一个简单是文件夹模块:</p>
            <p>目录结构如下:</p>
            <div class="content-img-container">
                <img src="../../assets/image-resources/blogs/nodejs-module/1.png"></img>
            </div>
            <p>staticdata.js文件内容如下:</p>
            <pre><code class="javascript">
module.exports = {
    data: 'this is data'
};
            </code></pre>
            <p>index.js文件内容如下:</p>
            <pre><code class="javascript">
var staticdata = require('./staticdata');

module.exports = {
    fun: function(){
        console.log(staticdata.data);
    }
};
            </code></pre>
            <p>解释module.exports到底是个什么样的数据, 是怎么传入闭包并返回的 ??</p>
            <h2>node_modules</h2>
            <p>node_modules是Node工程用来保存第三方模块的文件夹. 通过npm安装的第三方模块都会出现在这个文件夹中. Node工程中有一个package.json的文件, 用来定义该工程依赖的所有第三方模块, 然后只需要通过命令npm install就可以安装所有package.json中指定的第三方模块到node_modules文件夹内.</p>
            <div class="warning">
                <span>在通过文件夹的方式定义模块, 并希望该模块依赖一些第三方的模块时, 只需要在该模块中定义package.json即可, 不要在该模块的目录下执行命令npm install, 若该模块的依赖项和整个工程的依赖项重复, 则会导致不必要的内存浪费. 当引入文件夹形式的模块时, 主工程的package会自动加入依赖.</span>
            </div>
            <div class="warning">
                <span>工程的依赖项又会去依赖其他第三方模块, 这样会不会导致依赖项链过长 ??????</span>
            </div>
            <h2>require</h2>
            <p>require是Node模块系统提供的加载模块的全局方法, require会返回指定模块中定义的exports对象中的内容. </p>
            <p>require是<span class="key-word">同步加载</span>, 所有的同步调用都会阻塞Node, 知道加载完成才能做其他的事情. 所以通常是在文件最初加载时引入模块, 而不是将模块加载代码放在业务逻辑代码中, 否则会导致程序假死.</p>
            <p>require的第一个参数是模块的名字或者相对路径, 当参数是相对路径时, 即明确指定了模块存放的目录时, 无二意, 直接加载, 如果在指定目录中没有找到, 模块系统也没有其他的备选目录, 则会报错. 当参数是模块名时, 则会出现以下情况:</p>
            <ul>
                <li>首先会到当前同级目录中去找, 如果有则加载, 没有则采用下一个策略.</li>
                <li>当前同级目录中不存在指定模块时, 模块系统会到当前目录下的node_modules文件夹中查找, 即认为可能是从npm获取的模块.</li>
                <li>若当前目录下的node_modules文件夹中也没有指定模块, 则逐层遍历父目录的node_modules文件夹.</li>
                <li>若所有的父目录的node_modules文件夹中都没有, 则到环境变量NODE_PATH指定的目录中去找.</li>
                <li>如果依旧没有找到, 则抛出异常.</li>
            </ul>
            <h2>package.json文件</h2>
            <p>package.json是模块的配置文件, 包括模块的名字, 版本号, 入口文件, 依赖模块等. 这些属性决定了模块的内容. 每个模块都应该有这样一个文件.</p>
            <p>package.json中的属性定义了模块的不同内容, 下面是一个定义比较完整的模块的package.json文件的内容:</p>
<pre><code class="javascript">
{
    "name": "apps-server",
    "version": "1.0.0",
    "main": "Gruntfile.js",
    "private": true,
    "scripts": {
        "start": "grunt server"
    },
    "dependencies": {
        "archiver": "0.10.0",
        "body-parser": "1.9.2",
        "cheerio": "0.13.1",
        "domelementtype": "1.1.1",
        "express": "4.10.2",
        "grunt": "0.4.5",
        "grunt-contrib-compress": "0.9.1",
        "grunt-contrib-jasmine": "0.6.3",
        "grunt-contrib-jshint": "0.10.0",
        "grunt-exec": "0.4.6",
        "grunt-jscs": "1.8.0",
        "handlebars": "2.0.0-alpha.2",
        "jasmine": "2.1.1",
        "jscs": "1.13.1",
        "jshint": "2.5.0",
        "less": "1.7.0",
        "lodash": "2.4.1",
    },
    "engines": {
        "node": ">=0.10.31"
    },
    "engineStrict": true,
    "devDependencies": {
        "fs-extra": "^0.16.3",
        "progress": "^1.1.8",
        "wget": "0.0.1",
        "yauzl": "^2.2.1"
    }
}
</code></pre>
            <p>对其中的一些字段进行简单的描述:</p>
            <h3>name, version</h3>
            <p>定义了当前模块的名称和版本号, 这两个属性唯一标示了一个模块. </p>
            <h3>main</h3>
            <p>定义模块的入口程序, 默认是index.js, 可以自己定义入口程序, 该入口程序中的module.exports对应的数据就是模块的内容.</p>
            <h3>dependencies</h3>
            <p>为模块所依赖的其他模块的版本的hash, 版本号需满足semver的规范.</p>
            <p><strong>Reference: <a onclick="window.open('http://semver.org/');">node-semver官方文档</a></strong></p>
            <h3>devDependencies</h3>
            <p>一些额外模块的版本的hash, 如果发布该模块, 也就是开发中需要的模块, 比如测试模块等. 当执行npm install命令时, devDependencies中的依赖也会被安装, 需要执行npm install --production可以忽略devDependencies中定义的依赖.</p>
            <p><strong>Reference: <a onclick="window.open('https://github.com/npm/npm/issues/1434');">如何通过命令忽略devDependencies中定义的依赖</a></strong></p>
            <h3>bin</h3>
            <p></p>
            <h3>scripts</h3>
            <p>是一个从包生命周期的阶段到脚本命令的hash对象, 该例子中的scripts表示启动命令采用grunt server,scripts默认值是 <span class="key-word">"scripts": {"start": "node server.js"}</span>. 即默认将start命令设置为node server.js</p>
            <h3>engines</h3>
            <p>用于定义该模块执行的node版本.</p>
            <p><strong>Reference: <a onclick="window.open('https://docs.npmjs.com/files/package.json');">node关于package.json的官方文档( 英文 )</a></strong></p>
            <p><strong>Reference: <a onclick="window.open('http://www.mujiang.info/translation/npmjs/files/package.json.html');">node关于package.json的官方文档的国内翻译版本, 翻译质量一般</a></strong></p>
    </article>
</div>