<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>在浏览器中输入一个URL时会发生什么</h1>
            <p class="subline">常识解答</p>
            <p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/7/12</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>当在浏览器中输入URL, 从按回车到浏览器显示内容, 这一段时间到底发生了什么? </p>
            <p>这个问题在技术面试中出场率较高, 能考查网络通信, DNS, HTTP协议, 服务器端解析HTTP请求, 服务器端处理请求结果, 浏览器解析和渲染HTML文档, 事件处理等内容. 很全面, 很考查内功.</p>
            <p>应该从这三个方面考虑这个问题: 浏览器如何生成HTTP报文, 服务器如何处理HTTP请求, 浏览器解析服务器的响应.</p>
            <h2>浏览器如何生成HTTP报文</h2>
            <p>HTTP报文是面向文本的. 报文中的每一个字段都是一些ASCII码串. 报文格式如下: </p>
            <div class="content-img-container">
                <img src="../assets/image-resources/blogs/what-will-happen-when-enter-url/1.jpg"></img>
            </div>
            <p>浏览器会在<span class="key-word">HTTP报文</span>的请求行中填入请求方式, 在这里为<span class="key-word">GET</span>方法, 填入URL, 即输入的URL, 以及协议版本. 在请求头中填入请求头内容, 在报文体中加入要附带的数据. 但是这种情况没有附带的数据. 下面是输入www.baidu.com的请求内容: </p>
            <div class="content-img-container">
                <img src="../assets/image-resources/blogs/what-will-happen-when-enter-url/4.png"></img>
            </div>
            <p>同时, 浏览器还会从URL中解析出目的主机名, 并使用应用层的DNS解析出目的IP.</p>
            <p>生成HTTP报文是应用层的事情, 因为HTTP协议是应用层的协议. 生成的HTTP报文做作为传输层的TCP协议的内容, 并在TCP头中添加当前IP和目标IP, 形成<span class="key-word">TCP报文</span>. </p>
            <p>到此, TCP报文已经准备就绪, 在发送真正的数据之前, 还要经过<span class="key-word">TCP的三次握手</span>. 然后才会发送真正的数据. </p>
            <h2>服务器如何处理HTTP请求</h2>
            <p>终于, 数据经过路由, 并通过指定的端口, 终于到达了服务器, 服务器在应用层得到了HTTP报文, 从而也就知道了请求的详细内容. </p>
            <p>当服务器上没有指定该路由的响应, 会尝试获取该URL对应的文件数据, 当文件不存在时, 返回404. 当有访问权限并成功读取到文件内容时, 返回200, 并将文件内容放在HTTP响应的数据段中, 一般情况下会根据文件格式设置<span class="key-word">Content-Type</span>.</p>
            <p>当服务器上定义了该路由的响应, 则根据具体的逻辑生成HTTP响应内容, 如果返回的HTML文档的话, 一般来说会经历读取HTML文件或者<span class="key-word">读取模板并渲染</span>的过程. 并将状态码设置为200. 如果出现程序错误, 则返回500. HTTP响应报文格式如下: </p>
            <div class="content-img-container">
                <img src="../assets/image-resources/blogs/what-will-happen-when-enter-url/2.jpg"></img>
            </div>
            <p>下面是请求www.baidu.com的HTTP响应头的内容: </p>
            <div class="content-img-container">
                <img src="../assets/image-resources/blogs/what-will-happen-when-enter-url/3.png"></img>
            </div>
            <p>最终会生成HTTP响应, 并发送给客户端. 报文从应用层到链路层也会经过和客户端发送HTTP请求一样的过程. </p>
            <h2>浏览器解析服务器的响应</h2>
            <p>此时, 客户端从监听的端口上收到了服务器返回的数据. 如果响应数据不是HTML格式, 则将其作为字符串显示在<span class="key-word">body</span>中. 经过简单的渲染就呈现给用户.</p>
            <p>如果是HTML格式, 要经过浏览器复杂的渲染过程, 过程如下: </p>
            <ul>
                <li>从HTML文档的第一个字符开始解析. 递归的解析成DOM树.</li>
                <li>当遇到script标签, 会通过同步请求获取js代码, 并在得到响应时执行响应的js代码. 请求的方式也是HTTP请求. 如果请求的js代码中影响了前面已经渲染的元素, 将重新渲染影响到的元素. (是渲染吗???)</li>
                <li>当遇到link标签获取css文件时, 同样会通过同步请求获取css文件, 获取到就渲染吗?????. </li>
                <li>当遇到图片资源, 视频资源时, 会通过异步的方式去获取资源, 即会继续解析后面的元素. 当请求的资源返回时, 再渲染???图片或者视频对应的元素.</li>
                <li>各种资源文件都是会在浏览器中<span class="key-word">缓存</span>的. 所以如果以前请求过, 那么后面的请求会很快.</li>
            </ul>
            <p>在解析过程中执行的js文件会为页面添加交互, 即事件绑定, 实现页面用户的交互. </p>
            <p><strong>Reference: <a onclick="window.open('http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/');">what really happens when you navigate to a url</a></strong></p>
        </div>
    </article>
</div>