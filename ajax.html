<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>Ajax详解</h1>
            <p class="subline">Ajax的实现方式和分析,XHR的介绍,同源策略和跨域访问的介绍,以及JSONP的原理</p>
            <p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/5/22</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>Ajax是实现与服务器交互的新方法。Ajax的全称是Asynchronous Javascript And XML，从命名上可以看出，是采用了Javascript的异步机制和XML这两种技术，其中异步机制实现非阻塞的IO，XML来用表示HTTP请求。</p>
            <p>所以，我们需要了解异步Javascript和XML HTTP请求即XmlHttpRequest两个概念。</p>
            <h3>异步Javascript</h3>
            <p>异步是指：程序不会去等待某个费时操作（比如I/O,服务器请求）返回结果，而是继续执行后面的操作，当结果返回时，再转而继续执行定义好的回调函数。Javascript是单线程执行的，它不像Java那样能够支持多线程和并发操作。那么，作为单线程的Javascript就应该尽量让线程不要停下来，否则，整个程序都会陷入“假死”状态。在处理像I/O这样非常费时的操作时，为了获得良好的用户体验，决定了非阻塞I/O的合理性。</p>
            <div class="warning">
                <span>与返回数据相关的操作要放在数据请求的回调函数中，否则数据的可靠性会变得很差。</span>
            </div>
            <p>Javascript有很多优秀的开源库，其中就有不少封装了异步机制的库，比如jQuery的Deferred对象，Q.js，bluebird等。他们在实现异步方面的差异请参考<span class="key-word">Javascript单线程</span>。了解他们在执行顺序上的区别对理解异步有很大的帮助。比如，下面一个例子：</p>
<pre><code class="javascript">
//用jQuery的Deferred对象
var cache = {'YCS': 'YaoChuansong'}
var getName = function(nickname) {
    if(!cache[nickname]) {
        return cache[nickname];
    } else {
        return $.ajax({
            url: 'XXXX',
            method: 'GET'
        });
    }
};
getName().then(function(name) {
    console.log('get his name:', name);
});
console.log('here is the end of code block');
/* 	OUTPUT:
get his name YaoChuansong
here is the end of code block
*/


//用Q
var cache = {'YCS': 'YaoChuansong'}
var getName = function(nickname) {
    if(!cache[nickname]) {
        return cache[nickname];
    } else {
        return Q($.ajax({
            url: 'XXXX',
            method: 'GET'
        }));
    }
};
getName().then(function(name) {
    console.log('get his name:', name);
});
console.log('here is the end of code block');
/* 	OUTPUT:
here is the end of code block
get his name YaoChuansong
*/
</code></pre>
            <p>jQuery的Deferred对象并不保证执行序列总是异步的，而Q，bluebird则保证所有执行序列总是异步的。</p>
            <h3>XmlHttpRequest</h3>
            <p>XMLHttpRequest最早由Microsoft设计并发布。现在已经是W3C标准的一部分。它用XML格式去表示HTTP请求（那以前是用什么表示的HTTP请求？）。之所以用XML，是利用了XML跨平台的特点。</p>
            <h4>XHR的headers</h4>
            <p>在利用XHR发送一个请求的过程中，需要设置URL，以及对XHR的各个字段进行设置，这些字段将直接影响XHR的执行结果，这些字段包括附带的数据格式，希望服务器返回的数据格式等，用来描述整个HTTP报文。下面是个例子：</p>
<pre><code class="javascript">
var xhr;
if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    xhr = new ActiveXObject("Microsoft.XMLHTTP");
}
xhr.open('get',	//请求的方法
         'age',	//url
         true);	//是否使用异步请求
xhr.setRequestHeader("Content-type","text/plain");	//"Content-type" 描述附加数据的类型
xhr.setRequestHeader("Accept","text/plain");		//"Accept" 描述希望服务器返回数据的类型
xhr.onreadystatechange = function(){			//请求成功以后的回调函数
    console.log('get his name ', xhr.responseText);
};
//发送请求
xhr.send("name=aron");
</code></pre>
            <p>HTTP报文的各个header含义如下：</p>
            <ul>
                <li>Content-type：附加数据的数据类型</li>
                <li>Accept：希望服务器返回的数据类型</li>
            </ul>
            <h4>XHR请求的状态码</h4>
            <p>当我们需要了解请求的执行状态时，可以通过XHR的状态码来识别。状态码分为两种，readyState和Status，他们都是XmlHttpRequest对象的两个成员。前者表示XHR的执行情况，如未发送，已发送正在等待服务器答复，服务器已返回等。后者表示服务器的执行状态码，与服务器端的代码执行情况有关。</p>
            <p>readyState状态码</p>
            <ul>
                <li>0：对象未初始化，即没用调用open方法。</li>
                <li>1：请求未发出，即还没有调用send方法。</li>
                <li>2：请求已经发送，服务器正在处理中。</li>
                <li>3：请求已经发送，已经收到了部分返回数据，数据不完整。</li>
                <li>4：请求已经完成，可以读取完整的返回数据。</li>
            </ul>
            <p>Status状态码</p>
            <ul>
                <li>1XX：一些信息状态码，不表示请求成功或者失败。</li>
                <li>2XX：代表正常，其中最常见的200表示一切OK。</li>
                <li>3XX：请求未发出，即还没有调用send方法。</li>
                <li>4XX：客户端错误，如404表示请求文件未找到。</li>
                <li>5XX：服务器端错误。</li>
            </ul>
            <p>所以，如果想得到正确的服务器返回数据，代码需要这么写：</p>
<pre><code class="javascript">
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4 && xhr.status === 400) {
        console.log('It is really succeed.Get ', xhr.responseText);
    }
};
</code></pre>
            <h4>XHR的数据解析</h4>
            <p>XHR有不同的发送请求的方法，包括GET,POST,HEAD等。在使用GET或者POST时，我们可以通过给send传递一个参数为请求附加数据，参数的类型是任意的。</p>
            <p>一般来说，GET请求是用来请求数据的，比如请求用户信息等。GET请求的数据是附加在URL上的，这样就使得附加的数据很透明，不够安全。POST请求通常是用来向服务器上存数据，或者要求服务器进行某个操作，客户端只需要了解操作的状态，比如删除一个文件，客户端只需要知道删除成功或者失败即可。POST请求的数据是放在header中的。（具体是怎么放的？格式？字段？）</p>
            <p>我们可以从XHR的responseText中获取数据的字符串形式，然后解析成我们需要的数据类型？？？。在使用jQuery发送Ajax请求时，会设置Accept字段，该字段定义了希望服务器返回的数据的类型。jQuery会自动的将responseText转化为对应的Accept字段描述的类型，然后直接通过异步回调函数的参数获取转换后的数据。字符串，JSON很好处理，可以直接操作。XML的解析有点复杂，下面是一段解析的代码：</p>
            <pre><code class="javascript">
xmltext="<note>";
xmltext+="<to>George</to>";
xmltext+="<from>John</from>";
xmltext+="<heading>Reminder</heading>";
xmltext+="<body>Don't forget the meeting!</body>";
xmltext+="</note>";
try //Internet Explorer
{
    xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
    xmlDoc.async="false";
    xmlDoc.loadXML(xmltext);
}catch(e)
{
    try //Firefox, Mozilla, Opera, etc.
    {
        parser=new DOMParser();
        xmlDoc=parser.parseFromString(xmltext,"text/xml");
    }
    catch(e)
    {
        alert(e.message);
        return;
    }
}
console.log( xmlDoc.getElementsByTagName("to")[0].childNodes[0].nodeValue );
console.log( xmlDoc.getElementsByTagName("from")[0].childNodes[0].nodeValue );
console.log( xmlDoc.getElementsByTagName("body")[0].childNodes[0].nodeValue );
//jQuery
var xmlDoc = $.parseXML( xmltext );
var $xml = $( xmlDoc );
console.log($xml.find( "to" ));
console.log($xml.find( "from" ));
console.log($xml.find( "body" ));
            </code></pre>
            <h3>利用XHR发送请求的详细过程</h3>
        </div>
    </article>
</div>