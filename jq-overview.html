<div class="blog-body">
    <header class="header">
        <div class="title">
            <h1>jQuery框架结构</h1>
            <p class="subline">jQuery的模块划分</p>
            <p class="blog-time"><strong>姚川松</strong> 写于 <strong>2015/5/23</strong></p>
        </div>
    </header>
    <article class="article-content">
        <div>
            <p>jQuery是Web前端用得最多的Javascript库之一。它提供了很多的方便开发的库和API。主要是：元素选择器selector，DOM操作，对ajax的封装，对事件绑定和动画的封装。</p>
            <h2>元素选择器selector</h2>
            <p>jQuery的选择器又分为层次选择器，过滤选择器两类。先给出一个页面结构，后面的选择器例子均可用于该页面结构：</p>
<pre><code class="html">
&lt;div&gt;
    &lt;div class="buttons"&gt;
        &lt;button id="button1" class="super-button button1"&gt;nihao&lt;/button&gt;
        &lt;button id="button2" class="small-button"&gt;&lt;/button&gt;
        &lt;button id="button3" class="super-button"&gt;&lt;/button&gt;
        &lt;input class="my-input" type="checkbox" checked="checked" id="input1"&gt;&lt;/input&gt;
    &lt;/div&gt;
    &lt;div class="buttons"&gt;
        &lt;button class="super-button"&gt;&lt;/button&gt;
    &lt;/div&gt;
    &lt;input class="my-input" id="input2"&gt;&lt;/input&gt;
&lt;/div&gt;
</code></pre>
            <p>jQuery的selector是使用了开源的Javascript框架Sizzle.</p>
            <p><strong>Reference: <a href="http://blog.bigbinary.com/2010/02/15/how-jquery-selects-elements-using-sizzle.html">How jquery selects elements using sizzle</a></strong></p>
            <h4>层次选择器</h4>
            <p>主要是针对元素的相对父子关系为条件的元素选择，主要是子元素选择器<span class="key-word">' '(空格)</span>，直接子元素选择器<span class="key-word">'>'</span>，同级元素选择器<span class="key-word">'~'</span>，直接同级元素选择器<span class="key-word">'+'</span></p>
<pre><code class="javascript">
$('#button1');			    //id选择器
$('.small-button');		    //class选择器
$('button');			    //tagname选择器
$('button, #button1')		//并行选择器，满足每个条件的元素的并集
$('.buttons #button1')		//子元素选择器，class属性包含buttons的元素的子元素中查找id为button1的元素
$('.buttons').find('#button1') //等价于上一行代码
$('.buttons#button1')		//class属性包含buttons并且id为button1的元素
$('.buttons>button')		//直接子元素选择器，button必须为.buttons的第一个子元素，即紧邻的子元素
$('.buttons').next('button')	//等价于上一行代码
$('.buttons>.small-button')	//结果为[]
$('.buttons+div')		    //直接同级元素选择器，即同级元素中最靠近.buttons的元素
$('.buttons').next('div');	//等价于上一行代码
$('.buttons~div')		    //同级元素选择器，与.buttons同级的标签为div的元素
$('.buttons').siblings('div');//等价于上一行代码
</code></pre>
            <div class="warning">
                <span>Warning: 注意有空格和没有空格的区别</span>
            </div>
            <h4>过滤选择器</h4>
            <p>选择过滤器又分为根据索引，状态，内容，属性等。</p>
<pre><code class="javascript">
//基于索引
$('.buttons:not(.small-button)');//选择$('.buttons')结果中排除class为small-button的元素
$('.buttons:first');		    //选择$('.buttons')结果中第一个元素
$('.buttons:first-child');	    //选择$('.buttons')结果中的元素的第一个子元素
$('.buttons:last');		        //选择$('.buttons')结果中第一个元素
$('.small-button:parent');	    //选择$('.small-button')结果的父元素  ？？？
$('.buttons:eq(2)');	    	//选择$('.buttons')结果中第二个元素
$('.buttons:gt(2)');	    	//选择$('.buttons')结果中下标大于2的元素，不包含2，索引从0开始
$('.buttons:nth-child(3n+1)');	//选择$('.buttons')结果中第4,7...个元素，n从1开始
//基于状态
$('input:focus');		//过滤拥有焦点的input元素
$('input:checked');		//过滤状态为选取状态的类型为checkbox的input元素
$('input:visible');		//过滤隐藏的input元素
$(':focusable');		//过滤可以设置焦点的元素
//基于内容
$('button:contains(button1)');//过滤出文本内容包含button1的元素
$('.buttons:has(.super-button)');//过滤出子元素含有.super-button元素的buttons元素
$('button:empty');		     //过滤出不包含子元素和文本的button元素
//基于属性
$('button[id]');	         //过滤出拥有id属性的button元素
$('button[id=button1]');	 //过滤出拥有id属性值为button1的button元素
$('button[id^=button1]');    //过滤出拥有id属性值以button1开始的button元素
$('button[id$=button1]');    //过滤出拥有id属性值以button1结束的button元素
$('button[id*=button1]');    //过滤出拥有id属性值含有button1的button元素
$('button[class~=button1]'); //过滤出拥有class属性值含有button1的button元素，其中class属性必须以空格分隔class名
$('input[id][type=checkbox]');//过滤出拥有id属性，并且type属性值为checkbox的input元素
</code></pre>
            <h2>DOM操作</h2>
            <p>DOM全称是Document Object Model(文档对象模型),DOM操作是web前端开发中构造动态页面必不可少的内容。DOM操作主要包括DOM的创建和插入，获取DOM的数据信息两部分。下面是一些简单代码：</p>
<pre><code class="javascript">
//DOM的创建和插入
var $bt = $('&lt;button class="special-button" id="button4"&gt;test for DOM operation&lt;/button&gt;');
$('.buttons:eq(0)').append($bt);	//插入到.buttons的最后
$bt.appendTo($('.buttons:eq(0)'));	//插入到.buttons的最后
$('.buttons:eq(0)').prepend($bt);	//插入到.buttons的最前面
$bt.prependTo($('.buttons:eq(0)'));	//插入到.buttons的最前面
$('.buttons:eq(0)').after($bt);		//插入到.buttons的后面，成为.buttons的直接同级元素
$('.buttons:eq(0)').before($bt);	//插入到.buttons的前面，成为.buttons的同级元素，与.buttons紧邻，并在.buttons之前
$('.buttons:eq(0)').wrap('<div></div>');//将.buttons包裹在一个div标签中
//DOM的删除
$('.buttons button:last').remove();	//删除这个DOM
$('.buttons button:last').detach();	//从DOM树中移除，返回DOM对象
$('.buttons button:last').empty();	//将该DOM的内容清空，内容包括子元素和本文
//DOM属性操作
$('.buttons button:last').attr('id');		//获取id属性
$('.buttons button:last').attr('class');	//获取class属性，jQuery没有获取class的方法
$('.buttons button:last').attr('id', 'newid');//设置id属性
$('.buttons button:last').removeAttr('id');	//删除id属性
$('.buttons button:last').css('height');	//获取style的height值
$('.buttons button:last').css('height', '100px');//设置style的height值
$('.buttons button:last').addClass('myclass');//添加class
$('.buttons button:last').removeClass('myclass');//删除class
$('.buttons button:last').hasClass('myclass');//判断是否含有class
$('.buttons button:last').is('.myclass');	//等同于上一行代码
$('.buttons button:last').text();			//获取文本信息
$('input:last').val();	                    //获取input元素的内容
</code></pre>
            <h2>事件绑定和动画</h2>
            <h4>事件绑定</h4>
            <p>jQuery对事件绑定进行了封装，提供了多个不同的API以满足coder在不同环境下的不同需求。jQuery提供了bind, live, delegate, on四种绑定事件的方法，其中on是一个通用接口，其他三种绑定方法适用于不同的需求，主要区别在于动态元素和静态元素的事件绑定上，具体参考<span class="key-word">jQuery事件机制</span>。</p>
            <h4>动画</h4>
            <p>jQuery提供了animate函数封装了动画效果的复杂实现，屏蔽了浏览器的兼容性。具体参考<span class="key-word">CSS实现动画</span>中关于用jQuery实现动画的内容。</p>
            <h2>ajax的封装</h2>
            <p>ajax不是一个新技术，而是通过采用XML技术和Javascript异步来实现的一种与服务器的交互方式。jQuery为此实现了自己的Javascript异步控制对象：Deferred对象，以支持请求返回后的回调操作。jQuery封装了使用XHR来实现服务器交互的代码，只对coder提供了一个$.ajax接口，大大方便了开发。并且实现了对浏览器的兼容。</p>
            <h2>jQuery的优势和劣势</h2>
            <p>jQuery是一个很强大的开源库，提供了非常多有用的API，屏蔽了底层的使用细节，并拥有浏览器兼容性，不用再为绑定事件和处理事件的浏览器兼容费脑经了。但是它只是提供了一套工具，没有提供前端的模块划分，实现高内聚低耦合的代码结构的解决方案，所以它非常适合于作为前端框架的依赖库来使用，而不是仅仅依靠jQuery提供的API来开发应用。</p>
        </div>
    </article>
</div>